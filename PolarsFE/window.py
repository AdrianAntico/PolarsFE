from typing import List, Union, Optional, Any
import polars as pl

def lags(
    data: pl.DataFrame,
    date_col: str,
    columns: List[str],
    lags: Union[int, List[int]] = 1,
    group_vars: Optional[List[str]] = None,
    fill_value: Optional[Any] = None,
    is_sorted: bool = False
) -> pl.DataFrame:
    """
    Create lag features for specified columns in a Polars DataFrame.

    The function first sorts the DataFrame by the date column (and, if provided, by the grouping variables)
    and then computes lag features for each column in `columns` for each lag in `lags`.

    Parameters:
      data (pl.DataFrame): The input DataFrame.
      date_col (str): The name of the datetime column to sort by.
      columns (List[str]): A list of column names for which to create lag features.
      lags (Union[int, List[int]]): A single lag or a list of lags to compute (default is 1).
      group_vars (Optional[List[str]]): A list of grouping columns. If provided, lag features are computed within each group.
      fill_value (Optional[Any]): An optional value to fill missing values generated by the lag operation.

    Returns:
      pl.DataFrame: A DataFrame with additional lag feature columns appended. Each new column is named
                    "{column}_lag_{lag}".

    Example:
      from PolarsFE import window

      # Create a sample DataFrame.
      df = pl.DataFrame({
          "date": ["2023-01-01", "2023-01-02", "2023-01-03", "2023-01-04", "2023-01-05", "2023-01-06"],
          "sales": [100, 150, 200, 250, 300, 350],
          "store": ["A", "A", "B", "B", "A", "B"]
      })
      
      print("=== Original DataFrame ===")
      print(df)

      # Create lag features for "sales" with lags 1 and 2.
      # Compute lags within each store.
      df_lags = window.lags(df, date_col="date", columns=["sales"], lags=[1,2], group_vars=["store"], fill_value=0)

      print("\n=== DataFrame with Lag Features ===")
      print(df_lags)
    """
    # Ensure that lags is a list.
    if isinstance(lags, int):
        lags = [lags]
    
    # Sort the data: if grouping variables are provided, sort by group_vars and then by the date column.
    if not is_sorted:
        if group_vars is not None:
            sort_cols = group_vars + [date_col]
        else:
            sort_cols = [date_col]
        data_sorted = data.sort(sort_cols)
    
    # Build a list of lag expressions.
    lag_exprs = []
    for col in columns:
        for lag in lags:
            expr = pl.col(col).shift(lag)
            if group_vars is not None:
                # Compute lag values over each group.
                expr = expr.over(group_vars)
            if fill_value is not None:
                expr = expr.fill_null(fill_value)
            lag_exprs.append(expr.alias(f"{col}_lag_{lag}"))
    
    # Append the lag columns to the sorted DataFrame.
    data_out = data_sorted.with_columns(lag_exprs)
    return data_out


def rolling_features(
    data: pl.DataFrame,
    date_col: str,
    columns: List[str],
    window: Union[int, List[int]] = 3,
    agg: str = "mean",
    group_vars: Optional[List[str]] = None,
    fill_value: Optional[Any] = None,
    is_sorted: bool = False,
    min_samples: Optional[int] = 1,
    center: bool = False
) -> pl.DataFrame:
    """
    Create rolling window (moving aggregate) features for specified columns in a Polars DataFrame.
    
    The function optionally sorts the DataFrame by the date column (and group variables, if provided)
    and then computes the specified rolling aggregate for each column over the provided window size(s).
    
    Supported aggregation functions (case-insensitive) include:
      - "mean": Rolling mean.
      - "min": Rolling minimum.
      - "max": Rolling maximum.
      - "std": Rolling standard deviation.
      - "sum": Rolling sum.
    
    Parameters:
      data (pl.DataFrame): The input DataFrame.
      date_col (str): The name of the datetime column to sort by.
      columns (List[str]): A list of numeric column names for which to compute rolling features.
      window (Union[int, List[int]]): A single window size or a list of window sizes (in number of rows). Default is 3.
      agg (str): The aggregation function to use ("mean", "min", "max", "std", "sum"). Default is "mean".
      group_vars (Optional[List[str]]): If provided, the DataFrame is grouped by these columns and the rolling
                                        calculation is done within each group.
      fill_value (Optional[Any]): If provided, missing values produced by the rolling window are filled with this value.
      is_sorted (bool): If True, the function assumes the DataFrame is already sorted by the date column (and group_vars).
                        If False, the function sorts the DataFrame.
      min_samples (Optional[int]): Minimum number of observations required in the window to have a value. Default is 1.
      center (bool): If True, the window is centered on each row. Default is False.
    
    Returns:
      pl.DataFrame: The input DataFrame with new rolling feature columns appended. Each new column is named
                    "{column}_{agg}_rolling_{window}".
    
    Example:
      from PolarsFE import window
      
      # Create a sample DataFrame.
      df = pl.DataFrame({
          "date": ["2023-01-01", "2023-01-02", "2023-01-03", "2023-01-04", "2023-01-05", "2023-01-06"],
          "sales": [100, 150, 200, 250, 300, 350],
          "store": ["A", "A", "B", "B", "A", "B"]
      })
      
      print("=== Original DataFrame ===")
      print(df)
      
      # Example 1: Compute rolling mean for "sales" with window sizes 2 and 3, grouped by "store".
      df_roll_mean = window.rolling_features(
          data=df,
          date_col="date",
          columns=["sales"],
          window=[2, 3],
          agg="mean",
          group_vars=["store"],
          fill_value=0,
          is_sorted=False,
          min_samples=1,
          center=False
      )
      print("\n=== DataFrame with Rolling Mean Features ===")
      print(df_roll_mean)
      
      # Example 2: Compute rolling standard deviation for "sales" with window size 3, grouped by "store".
      df_roll_std = window.rolling_features(
          data=df,
          date_col="date",
          columns=["sales"],
          window=3,
          agg="std",
          group_vars=["store"],
          fill_value=0,
          is_sorted=False,
          min_samples=1,
          center=False
      )
      print("\n=== DataFrame with Rolling Standard Deviation Features ===")
      print(df_roll_std)
    """
    # Ensure window is a list.
    if isinstance(window, int):
        window = [window]
    
    # Sort the DataFrame if not already sorted.
    if not is_sorted:
        if group_vars is not None:
            sort_cols = group_vars + [date_col]
        else:
            sort_cols = [date_col]
        data = data.sort(sort_cols)
    
    # Define a helper to get the rolling expression.
    def get_rolling_expr(col: str, w: int) -> pl.Expr:
        agg_lower = agg.lower()
        if agg_lower == "mean":
            expr = pl.col(col).rolling_mean(window_size=w, min_samples=min_samples, center=center)
        elif agg_lower == "min":
            expr = pl.col(col).rolling_min(window_size=w, min_samples=min_samples, center=center)
        elif agg_lower == "max":
            expr = pl.col(col).rolling_max(window_size=w, min_samples=min_samples, center=center)
        elif agg_lower == "std":
            expr = pl.col(col).rolling_std(window_size=w, min_samples=min_samples, center=center)
        elif agg_lower == "sum":
            expr = pl.col(col).rolling_sum(window_size=w, min_samples=min_samples, center=center)
        else:
            raise ValueError(f"Aggregation method '{agg}' is not supported.")
        return expr

    rolling_exprs = []
    for col in columns:
        for w in window:
            expr = get_rolling_expr(col, w)
            if group_vars is not None:
                expr = expr.over(group_vars)
            if fill_value is not None:
                expr = expr.fill_null(fill_value)
            rolling_exprs.append(expr.alias(f"{col}_{agg.lower()}_rolling_{w}"))
    
    return data.with_columns(rolling_exprs)
